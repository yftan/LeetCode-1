package 回溯法.N皇后问题.q51_N_Queens_II;

/**
 * 该方法使用了二进制计算+DFS深度优先遍历
 *
 * 1、使用常规深度优先一层层搜索
 *
 * 2、使用三个整形分别标记每一层哪些格子可以放置皇后，这三个整形分别代表列、左斜下、右斜下（_col, ld, rd_），
 *      二进制位为 1 代表上一层已经放置，这层就不能放置，0 代表上层没有放置，这层可以放置。
 *      所以本层可以放置的位置就是~(col, ld, rd)，取反的原因就是1好计算（这里取反换成1就代表是本层可以放置的），0不方便计算，看下面的循环就清楚了。
 *      在解释一下如果是二进制值为1按照3的方法就可以计算，如果是0，首先在二进制中逐个找出0的位置，然后记住位置，重新将该位置的值变成1，其余位置都是0，生成一个新的值，
 *      实际上和上面是一个效果
 *
 * 3、核心两个位运算：
 *      x & -x 代表除最后一位 1 保留，其它位全部为 0
 *      x & (x - 1) 代表将最后一位 1 变成 0
 *

 */
public class Solution {
    int res = 0;
    public int solveNQueens(int n) {
        dfs(4, 0,0 ,0 ,0);
        return res;
    }

    /**
     *
     * 详细解释：
     * 1. (1 << n) - 1 这个语句实际上生成了n个1.这里的1表示可以放置皇后（其实就是初始化了n个1，在不考虑皇后之间可以相互攻击的情况下，n个位置都可以放皇后；
     * (col | ld | rd)这里的三个变量分别代表了列以及两个斜线的放置情况。这里的1表示上一层已经放置过皇后。
     * 所以取反～(col | ld | rd)就是这层可以放置皇后的位置
     *
     * 这与之前 (1 << n) - 1生成的n个1是不同含义的。因此bits = ~(col | ld | rd) & ((1 << n) - 1)表示的是考虑了相应列、斜线后能放置皇后的位置。
     *
     * 举个例子：n=4时，初始化为1111，表示此时4个位置都可以放皇后，但是和~(col | ld | rd)按位与后变为了0110，表示此时只有第2个和第3个位置是可以放皇后的。
     *
     * 2.当bits>0时，说明bits中还有1存在，就说明遍历还没有完成。而在之后的循环体中，每遍历bits中的一个1，就会将其清0，这就是代码中注释部分5的语句。
     *
     * 3.这里的pick就是取出了最后一位1，表示此时遍历的是这种情况。假设bits为0110，取出最后一位1后，就变为0010，就是将皇后放在第3个位置。
     *
     * 4.这里是核心：row+1不难理解，就是因为之前已经在row行放置了皇后了，现在应该搜索下一行可能的位置了。col | pick就是把目前所有放置皇后的列都计算出来了，
     * 比如最开始计算时col是0000，pick是0010,那么col | pick就是0010，意思就是第三列被放置过了。接着说，假设ld是0000，ld | pick就是0010，左移1位后变成了0100，
     * 意思就是下一行的第二列也不要放皇后了，因为在这一行的第三列我已经放过了，他们是位于一个斜线上的。(rd | pick) >> 1跟(ld | pick) << 1是一个含义，就不赘述了。
     *
     *
     * @param n
     * @param row
     * @param col
     * @param ld
     * @param rd
     */
    public void dfs(int n, int row, int col, int ld, int rd){
        if (row >= n) { res++; return; }

        // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历
        int bits = ~(col | ld | rd) & ((1 << n) - 1); //1
        while (bits > 0) { // 2
            int pick = bits & -bits; // 注: x & -x 3
            // col | pick, (pick | ld) <<1 , (pick | rd)>>1  这几个是告诉下一层，我这一层选择了这些你下一层不能选。
            // 例如；本层  0010, 那么下一次就不能选 0111这三个位置。因为0100与0001与上一次形成了对角线
            dfs(n, row + 1, col | pick, (ld | pick) << 1, (rd | pick) >> 1); // 4
            bits &= bits - 1; // 注: x & (x - 1) 5
        }
    }

    public static void main(String[] args) {
        System.out.println(new Solution().solveNQueens(4));
    }
}
